//! Configuration writer for Axiom
//!
//! Saves configuration to `.axiom.toml` files.

use super::types::AxiomConfig;
use std::path::{Path, PathBuf};

/// Configuration writing error
#[derive(Debug, thiserror::Error)]
pub enum WriteError {
    #[error("Failed to serialize config: {0}")]
    SerializeError(#[from] toml::ser::Error),

    #[error("Failed to write config file: {0}")]
    WriteError(#[from] std::io::Error),

    #[error("Failed to create config directory: {0}")]
    CreateDirError(String),
}

/// Get the config file path for a project directory
///
/// Returns the path to `.axiom.toml` in the project root.
pub fn config_path(project_dir: &Path) -> PathBuf {
    project_dir.join(".axiom.toml")
}

/// Get the user config directory path
///
/// Returns `~/.config/axiom/config.toml` or equivalent on other platforms.
pub fn user_config_path() -> Option<PathBuf> {
    dirs::config_dir().map(|d| d.join("axiom").join("config.toml"))
}

/// Save configuration to a TOML file
///
/// # Arguments
/// * `config` - The configuration to save
/// * `path` - The path to write to
///
/// # Returns
/// * `Ok(())` on success
/// * `Err(WriteError)` on failure
pub fn save_config(config: &AxiomConfig, path: &Path) -> Result<(), WriteError> {
    // Ensure parent directory exists
    if let Some(parent) = path.parent() {
        if !parent.exists() {
            std::fs::create_dir_all(parent).map_err(|e| {
                WriteError::CreateDirError(format!("{}: {}", parent.display(), e))
            })?;
        }
    }

    // Serialize config to TOML
    let content = serialize_config(config)?;

    // Write to file
    std::fs::write(path, content)?;

    Ok(())
}

/// Serialize configuration to a formatted TOML string
fn serialize_config(config: &AxiomConfig) -> Result<String, toml::ser::Error> {
    // Build a nicely formatted config file with comments
    let mut output = String::new();

    output.push_str("# Axiom Configuration\n");
    output.push_str("# Generated by Axiom settings\n\n");

    output.push_str("[llm]\n");
    output.push_str("# Default provider: claude, gemini, ollama, openai\n");
    output.push_str(&format!(
        "default_provider = \"{}\"\n",
        config.llm.default_provider
    ));
    output.push_str(&format!(
        "\n# Request timeout in seconds\ntimeout = {}\n",
        config.llm.timeout
    ));
    output.push_str(&format!(
        "\n# Maximum retries for failed requests\nmax_retries = {}\n",
        config.llm.max_retries
    ));

    // Write each provider in a consistent order
    let provider_order = ["claude", "gemini", "ollama", "openai"];

    for provider_name in provider_order {
        if let Some(provider) = config.llm.providers.get(provider_name) {
            output.push_str(&format!("\n[llm.providers.{}]\n", provider_name));
            output.push_str(&format!("enabled = {}\n", provider.enabled));

            // Write API key if present (mask in comments but save actual value)
            if let Some(ref api_key) = provider.api_key {
                if !api_key.is_empty() && !api_key.starts_with("${") {
                    // Direct key value
                    output.push_str(&format!("api_key = \"{}\"\n", api_key));
                } else if !api_key.is_empty() {
                    // Environment variable reference
                    output.push_str(&format!("api_key = \"{}\"\n", api_key));
                }
            }

            // Write base URL if present
            if let Some(ref base_url) = provider.base_url {
                output.push_str(&format!("base_url = \"{}\"\n", base_url));
            }

            // Write default model if present
            if let Some(ref default_model) = provider.default_model {
                output.push_str(&format!("default_model = \"{}\"\n", default_model));
            }

            // Write models list if not empty
            if !provider.models.is_empty() {
                let models_str: Vec<String> =
                    provider.models.iter().map(|m| format!("\"{}\"", m)).collect();
                output.push_str(&format!("models = [{}]\n", models_str.join(", ")));
            }
        }
    }

    Ok(output)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_config_path() {
        let project_dir = Path::new("/home/user/project");
        let path = config_path(project_dir);
        assert_eq!(path, PathBuf::from("/home/user/project/.axiom.toml"));
    }

    #[test]
    fn test_serialize_default_config() {
        let config = AxiomConfig::default();
        let result = serialize_config(&config);
        assert!(result.is_ok());

        let content = result.unwrap();
        assert!(content.contains("[llm]"));
        assert!(content.contains("default_provider"));
        assert!(content.contains("[llm.providers.ollama]"));
    }

    #[test]
    fn test_save_config_creates_dirs() {
        use std::fs;

        // Use std temp dir with a unique name
        let temp_base = std::env::temp_dir();
        let test_dir = temp_base.join(format!("axiom_test_{}", std::process::id()));
        let nested_path = test_dir.join("subdir").join("config.toml");

        let config = AxiomConfig::default();
        let result = save_config(&config, &nested_path);
        assert!(result.is_ok());
        assert!(nested_path.exists());

        // Cleanup
        fs::remove_dir_all(&test_dir).ok();
    }
}
